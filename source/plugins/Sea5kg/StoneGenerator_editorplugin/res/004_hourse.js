// Code generated by deeseek

var generatorName = "Horse";
var generatorId = 4;

function generate(expected_triangles, radius) {
    print(expected_triangles);
    print(radius);

    // Model.clear();
    
    // Calculate approximate subdivisions
    var subdivisions = Math.round(Math.sqrt(expected_triangles / 20));
    if (subdivisions < 2) subdivisions = 2;
    
    var scale = radius;
    
    // Main body (ellipsoid)
    createBody(scale, subdivisions);
    
    // Head
    createHead(scale, subdivisions);

    // Legs
    createLegs(scale, subdivisions);

    // Neck
    createNeck(scale, subdivisions);

    // Tail
    createTail(scale, subdivisions);
}

function createBody(scale, subdivisions) {
    var bodyLength = scale * 2.0;
    var bodyHeight = scale * 0.8;
    var bodyWidth = scale * 0.6;
    
    // Create main body (ellipsoid-like)
    for (var i = 0; i < subdivisions; i++) {
        var theta1 = Math.PI * i / subdivisions;
        var theta2 = Math.PI * (i + 1) / subdivisions;
        
        for (var j = 0; j < subdivisions; j++) {
            var phi1 = 2 * Math.PI * j / subdivisions;
            var phi2 = 2 * Math.PI * (j + 1) / subdivisions;
            
            // Calculate vertices for body
            var x1 = Math.sin(theta1) * Math.cos(phi1) * bodyWidth;
            var y1 = Math.cos(theta1) * bodyHeight;
            var z1 = Math.sin(theta1) * Math.sin(phi1) * bodyLength * 0.5;
            
            var x2 = Math.sin(theta1) * Math.cos(phi2) * bodyWidth;
            var y2 = Math.cos(theta1) * bodyHeight;
            var z2 = Math.sin(theta1) * Math.sin(phi2) * bodyLength * 0.5;
            
            var x3 = Math.sin(theta2) * Math.cos(phi1) * bodyWidth;
            var y3 = Math.cos(theta2) * bodyHeight;
            var z3 = Math.sin(theta2) * Math.sin(phi1) * bodyLength * 0.5;
            
            var x4 = Math.sin(theta2) * Math.cos(phi2) * bodyWidth;
            var y4 = Math.cos(theta2) * bodyHeight;
            var z4 = Math.sin(theta2) * Math.sin(phi2) * bodyLength * 0.5;
            
            // Adjust body position
            z1 -= bodyLength * 0.3;
            z2 -= bodyLength * 0.3;
            z3 -= bodyLength * 0.3;
            z4 -= bodyLength * 0.3;
            
            var p1 = Model.addPoint(x1, y1, z1);
            var p2 = Model.addPoint(x2, y2, z2);
            var p3 = Model.addPoint(x3, y3, z3);
            var p4 = Model.addPoint(x4, y4, z4);
            
            Model.addTriangle(p1, p2, p4);
            Model.addTriangle(p1, p4, p3);
        }
    }
}

function createHead(scale, subdivisions) {
    var headLength = scale * 0.6;
    var headHeight = scale * 0.4;
    var headWidth = scale * 0.3;
    
    // Head position (front of body)
    var headZ = scale * 1.2;
    
    // Create head (ellipsoid)
    for (var i = 0; i < subdivisions; i++) {
        var theta1 = Math.PI * i / (subdivisions * 2);
        var theta2 = Math.PI * (i + 1) / (subdivisions * 2);
        
        for (var j = 0; j < subdivisions; j++) {
            var phi1 = 2 * Math.PI * j / subdivisions;
            var phi2 = 2 * Math.PI * (j + 1) / subdivisions;
            
            var x1 = Math.sin(theta1) * Math.cos(phi1) * headWidth;
            var y1 = Math.cos(theta1) * headHeight + scale * 0.3;
            var z1 = Math.sin(theta1) * Math.sin(phi1) * headLength + headZ;
            
            var x2 = Math.sin(theta1) * Math.cos(phi2) * headWidth;
            var y2 = Math.cos(theta1) * headHeight + scale * 0.3;
            var z2 = Math.sin(theta1) * Math.sin(phi2) * headLength + headZ;
            
            var x3 = Math.sin(theta2) * Math.cos(phi1) * headWidth;
            var y3 = Math.cos(theta2) * headHeight + scale * 0.3;
            var z3 = Math.sin(theta2) * Math.sin(phi1) * headLength + headZ;
            
            var x4 = Math.sin(theta2) * Math.cos(phi2) * headWidth;
            var y4 = Math.cos(theta2) * headHeight + scale * 0.3;
            var z4 = Math.sin(theta2) * Math.sin(phi2) * headLength + headZ;
            
            var p1 = Model.addPoint(x1, y1, z1);
            var p2 = Model.addPoint(x2, y2, z2);
            var p3 = Model.addPoint(x3, y3, z3);
            var p4 = Model.addPoint(x4, y4, z4);
            
            Model.addTriangle(p1, p2, p4);
            Model.addTriangle(p1, p4, p3);
        }
    }
    
    // Simple ears
    createEar(scale, headZ, true);  // left ear
    createEar(scale, headZ, false); // right ear
}

function createEar(scale, headZ, isLeft) {
    var earWidth = scale * 0.05;
    var earHeight = scale * 0.2;
    var earX = isLeft ? -scale * 0.15 : scale * 0.15;
    
    var baseY = scale * 0.6;
    var earZ = headZ + scale * 0.2;
    
    var p1 = Model.addPoint(earX, baseY, earZ);
    var p2 = Model.addPoint(earX - earWidth, baseY + earHeight, earZ);
    var p3 = Model.addPoint(earX + earWidth, baseY + earHeight, earZ);
    
    Model.addTriangle(p1, p2, p3);
}

function createNeck(scale, subdivisions) {
    var neckHeight = scale * 0.8;
    var neckWidth = scale * 0.2;
    
    // Connect body to head
    for (var i = 0; i < subdivisions; i++) {
        var angle1 = 2 * Math.PI * i / subdivisions;
        var angle2 = 2 * Math.PI * (i + 1) / subdivisions;
        
        // Bottom of neck (connected to body)
        var x1 = Math.cos(angle1) * neckWidth;
        var z1 = Math.sin(angle1) * neckWidth * 0.5 + scale * 0.5;
        var y1 = scale * 0.1;
        
        var x2 = Math.cos(angle2) * neckWidth;
        var z2 = Math.sin(angle2) * neckWidth * 0.5 + scale * 0.5;
        var y2 = scale * 0.1;
        
        // Top of neck (connected to head)
        var x3 = Math.cos(angle1) * neckWidth * 0.5;
        var z3 = scale * 0.8;
        var y3 = scale * 0.5;
        
        var x4 = Math.cos(angle2) * neckWidth * 0.5;
        var z4 = scale * 0.8;
        var y4 = scale * 0.5;
        
        var p1 = Model.addPoint(x1, y1, z1);
        var p2 = Model.addPoint(x2, y2, z2);
        var p3 = Model.addPoint(x3, y3, z3);
        var p4 = Model.addPoint(x4, y4, z4);
        
        Model.addTriangle(p1, p2, p4);
        Model.addTriangle(p1, p4, p3);
    }
}

function createLegs(scale, subdivisions) {
    var legRadius = scale * 0.08;
    var legHeight = scale * 0.8;
    
    // Four leg positions
    var legPositions = [
        { x: -scale * 0.4, z: -scale * 0.8 },  // back left
        { x: scale * 0.4, z: -scale * 0.8 },   // back right
        { x: -scale * 0.3, z: scale * 0.3 },   // front left
        { x: scale * 0.3, z: scale * 0.3 }     // front right
    ];
    
    for (var leg = 0; leg < 4; leg++) {
        var pos = legPositions[leg];
        
        for (var i = 0; i < subdivisions; i++) {
            var angle1 = 2 * Math.PI * i / subdivisions;
            var angle2 = 2 * Math.PI * (i + 1) / subdivisions;
            
            // Bottom circle
            var x1 = pos.x + Math.cos(angle1) * legRadius;
            var z1 = pos.z + Math.sin(angle1) * legRadius;
            var y1 = -scale * 0.8;
            
            var x2 = pos.x + Math.cos(angle2) * legRadius;
            var z2 = pos.z + Math.sin(angle2) * legRadius;
            var y2 = -scale * 0.8;
            
            // Top circle
            var x3 = pos.x + Math.cos(angle1) * legRadius * 0.8;
            var z3 = pos.z + Math.sin(angle1) * legRadius * 0.8;
            var y3 = -scale * 0.1;
            
            var x4 = pos.x + Math.cos(angle2) * legRadius * 0.8;
            var z4 = pos.z + Math.sin(angle2) * legRadius * 0.8;
            var y4 = -scale * 0.1;
            
            var p1 = Model.addPoint(x1, y1, z1);
            var p2 = Model.addPoint(x2, y2, z2);
            var p3 = Model.addPoint(x3, y3, z3);
            var p4 = Model.addPoint(x4, y4, z4);
            
            Model.addTriangle(p1, p2, p4);
            Model.addTriangle(p1, p4, p3);
        }
    }
}

function createTail(scale, subdivisions) {
    var tailBaseRadius = scale * 0.1;
    var tailTipRadius = scale * 0.02;
    var tailLength = scale * 0.8;
    
    var tailX = 0;
    var tailY = scale * 0.2;
    var tailZ = -scale * 1.5;
    
    for (var i = 0; i < subdivisions; i++) {
        var angle1 = 2 * Math.PI * i / subdivisions;
        var angle2 = 2 * Math.PI * (i + 1) / subdivisions;
        
        // Base of tail
        var x1 = tailX + Math.cos(angle1) * tailBaseRadius;
        var z1 = tailZ + Math.sin(angle1) * tailBaseRadius;
        var y1 = tailY;
        
        var x2 = tailX + Math.cos(angle2) * tailBaseRadius;
        var z2 = tailZ + Math.sin(angle2) * tailBaseRadius;
        var y2 = tailY;
        
        // Tip of tail
        var x3 = tailX + Math.cos(angle1) * tailTipRadius;
        var z3 = tailZ - tailLength + Math.sin(angle1) * tailTipRadius;
        var y3 = tailY + scale * 0.1;
        
        var x4 = tailX + Math.cos(angle2) * tailTipRadius;
        var z4 = tailZ - tailLength + Math.sin(angle2) * tailTipRadius;
        var y4 = tailY + scale * 0.1;
        
        var p1 = Model.addPoint(x1, y1, z1);
        var p2 = Model.addPoint(x2, y2, z2);
        var p3 = Model.addPoint(x3, y3, z3);
        var p4 = Model.addPoint(x4, y4, z4);
        
        Model.addTriangle(p1, p2, p4);
        Model.addTriangle(p1, p4, p3);
    }
}