// Code generated by deeseek

var generatorName = "Pyramid";

function generate(expected_triangles, radius) {
    print("expected_triangles: " + expected_triangles);
    print("radius: " + radius);

    // Model.clear();
    
    // Calculate subdivisions for the base
    var baseTriangles = expected_triangles - 4; // Reserve 4 triangles for the sides
    var trianglesPerSide = baseTriangles / 4; // 4 triangular sides
    
    // Calculate grid size for base (square base divided into triangles)
    var baseSubdivisions = Math.round(Math.sqrt(trianglesPerSide * 2));
    if (baseSubdivisions < 1) baseSubdivisions = 1;
    
    var step = 2 * radius / baseSubdivisions;
    var height = radius * 1.5; // Pyramid height
    
    // Create base vertices and triangles
    var baseVertices = [];
    
    // Generate base grid
    for (var i = 0; i <= baseSubdivisions; i++) {
        var row = [];
        for (var j = 0; j <= baseSubdivisions; j++) {
            var x = j * step - radius;
            var z = i * step - radius;
            var point = Model.addPoint(x, -radius, z);
            row.push(point);
        }
        baseVertices.push(row);
    }
    print(baseVertices.length);
    
    // Create base triangles
    for (var i = 0; i < baseSubdivisions; i++) {
        for (var j = 0; j < baseSubdivisions; j++) {
            print("j: " + j);
            var p00 = baseVertices[i][j];
            var p01 = baseVertices[i][j + 1];
            var p10 = baseVertices[i + 1][j];
            var p11 = baseVertices[i + 1][j + 1];
            
            // Create two triangles for each square
            print("Create two triangles for each square");
            Model.addTriangle(p00, p01, p11);
            Model.addTriangle(p00, p11, p10);
        }
    }
    
    // Create pyramid apex
    var apex = Model.addPoint(0, height, 0);
    
    // Create the four triangular sides
    var corners = [
        Model.addPoint(-radius, -radius, -radius), // front-left
        Model.addPoint(radius, -radius, -radius),  // front-right
        Model.addPoint(radius, -radius, radius),   // back-right
        Model.addPoint(-radius, -radius, radius)   // back-left
    ];
    
    // Create triangular sides
    for (var i = 0; i < 4; i++) {
        var next = (i + 1) % 4;
        Model.addTriangle(apex, corners[next], corners[i]);
    }
    
    // Add subdivided triangles for smoother sides if we have enough expected triangles
    if (baseSubdivisions > 1) {
        createSubdividedSides(apex, baseVertices, baseSubdivisions);
    }
}

function createSubdividedSides(apex, baseVertices, subdivisions) {
    // Create subdivided triangles for each side
    
    // Front side (z = -radius)
    for (var i = 0; i < subdivisions; i++) {
        for (var j = 0; j < subdivisions; j++) {
            var p0 = baseVertices[i][j];
            var p1 = baseVertices[i][j + 1];
            var p2 = baseVertices[i + 1][j];
            var p3 = baseVertices[i + 1][j + 1];
            
            // Front side triangles
            if (j === 0) {
                Model.addTriangle(apex, p1, p0);
            }
            if (i === subdivisions - 1 && j === 0) {
                Model.addTriangle(apex, p3, p1);
            }
            
            // Additional subdivision triangles for smoother sides
            if (i < subdivisions - 1 && j < subdivisions - 1) {
                Model.addTriangle(p0, p1, apex);
                Model.addTriangle(p1, p3, apex);
                Model.addTriangle(p3, p2, apex);
                Model.addTriangle(p2, p0, apex);
            }
        }
    }
    
    // Similar logic can be added for other sides...
}