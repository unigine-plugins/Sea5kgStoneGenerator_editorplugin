// Code generated by deeseek

var generatorName = "Crystal";
var generatorId = 5;
Math.PI = 3.141592653589793;

function generate(expected_triangles, radius) {
    print(expected_triangles);
    print(radius);

    // Model.clear();
    
    var subdivisions = Math.round(Math.sqrt(expected_triangles / 20));
    if (subdivisions < 3) subdivisions = 3;
    
    // Generate different crystal types based on triangle count
    if (expected_triangles < 1000) {
        createSimpleCrystal(radius, subdivisions);
    } else if (expected_triangles < 5000) {
        createMediumCrystal(radius, subdivisions);
    } else {
        createComplexCrystal(radius, subdivisions);
    }
}

function createSimpleCrystal(radius, subdivisions) {
    // Basic hexagonal crystal
    createCrystalPyramid(0, radius * 0.8, radius, subdivisions, 6); // Base
    createCrystalPyramid(0, -radius * 0.8, radius, subdivisions, 6); // Inverted
}

function createMediumCrystal(radius, subdivisions) {
    // More complex crystal with multiple facets
    var mainHeight = radius * 1.2;
    
    // Main body with hexagonal symmetry
    createCrystalPyramid(0, mainHeight, radius, subdivisions, 6);
    createCrystalPyramid(0, -mainHeight, radius, subdivisions, 6);
    
    // Secondary facets
    createCrystalPyramid(0, mainHeight * 0.6, radius * 0.7, subdivisions, 4);
    createCrystalPyramid(0, -mainHeight * 0.6, radius * 0.7, subdivisions, 4);
}

function createComplexCrystal(radius, subdivisions) {
    // Highly detailed crystal with multiple geometric elements
    var mainHeight = radius * 1.5;
    
    // Primary hexagonal structure
    createCrystalPyramid(0, mainHeight, radius, subdivisions, 6);
    createCrystalPyramid(0, -mainHeight, radius, subdivisions, 6);
    
    // Intermediate layers with different symmetries
    createCrystalPyramid(0, mainHeight * 0.7, radius * 0.8, subdivisions, 8);
    createCrystalPyramid(0, -mainHeight * 0.7, radius * 0.8, subdivisions, 8);
    
    // Small tetrahedral tips
    createCrystalPyramid(0, mainHeight * 1.1, radius * 0.3, subdivisions, 3);
    createCrystalPyramid(0, -mainHeight * 1.1, radius * 0.3, subdivisions, 3);
    
    // Add some irregular facets for natural look
    createIrregularFacets(radius, subdivisions);
}

function createCrystalPyramid(centerX, centerY, size, subdivisions, sides) {
    var vertices = [];
    
    // Create base vertices
    for (var i = 0; i < sides; i++) {
        var angle = 2 * Math.PI * i / sides;
        var x = centerX + Math.cos(angle) * size;
        var z = Math.sin(angle) * size;
        var basePoint = Model.addPoint(x, centerY, z);
        vertices.push(basePoint);
    }
    
    // Create apex (point of the pyramid)
    var apexY = centerY + (centerY >= 0 ? size * 0.8 : -size * 0.8);
    var apex = Model.addPoint(centerX, apexY, 0);
    
    // Create triangular faces from base to apex
    for (var i = 0; i < sides; i++) {
        var next = (i + 1) % sides;
        Model.addTriangle(apex, vertices[next], vertices[i]);
    }
    
    // Create base face
    if (sides > 3) {
        for (var i = 1; i < sides - 1; i++) {
            Model.addTriangle(vertices[0], vertices[i], vertices[i + 1]);
        }
    } else {
        // For triangles, just create the base
        Model.addTriangle(vertices[0], vertices[1], vertices[2]);
    }
    
    // Add subdivided faces for more detail
    if (subdivisions > 1) {
        createSubdividedPyramid(centerX, centerY, size, subdivisions, sides, apex, vertices);
    }
}

function createSubdividedPyramid(centerX, centerY, size, subdivisions, sides, apex, baseVertices) {
    var midVertices = [];
    
    // Create mid-level vertices for subdivision
    for (var i = 0; i < sides; i++) {
        var angle = 2 * Math.PI * i / sides;
        var midSize = size * 0.5;
        var midY = centerY + (centerY >= 0 ? size * 0.4 : -size * 0.4);
        
        var x = centerX + Math.cos(angle) * midSize;
        var z = Math.sin(angle) * midSize;
        var midPoint = Model.addPoint(x, midY, z);
        midVertices.push(midPoint);
    }
    
    // Create subdivided triangles
    for (var i = 0; i < sides; i++) {
        var next = (i + 1) % sides;
        
        // Upper section (apex to mid-level)
        Model.addTriangle(apex, midVertices[next], midVertices[i]);
        
        // Lower section (mid-level to base)
        Model.addTriangle(midVertices[i], midVertices[next], baseVertices[next]);
        Model.addTriangle(midVertices[i], baseVertices[next], baseVertices[i]);
    }
}

function createIrregularFacets(radius, subdivisions) {
    // Add some random facets to make crystal look more natural
    var facetCount = 4 + Math.floor(subdivisions / 2);
    
    for (var f = 0; f < facetCount; f++) {
        var angle = 2 * Math.PI * f / facetCount;
        var offset = radius * 0.3;
        var facetX = Math.cos(angle) * offset;
        var facetZ = Math.sin(angle) * offset;
        var facetSize = radius * (0.2 + Math.random() * 0.3);
        var facetSides = 3 + Math.floor(Math.random() * 3); // 3-5 sides
        
        createCrystalPyramid(facetX, radius * 0.5, facetSize, 2, facetSides);
        createCrystalPyramid(facetX, -radius * 0.5, facetSize, 2, facetSides);
    }
}

function createGeodeCrystal(radius, subdivisions) {
    // Alternative: geode-style crystal with internal structure
    var vertices = [];
    
    // Create outer shell
    for (var i = 0; i <= subdivisions; i++) {
        var theta = Math.PI * i / subdivisions;
        var row = [];
        
        for (var j = 0; j <= subdivisions; j++) {
            var phi = 2 * Math.PI * j / subdivisions;
            
            // Add some noise for crystal-like surface
            var noise = 1 + (Math.random() - 0.5) * 0.2;
            var x = Math.sin(theta) * Math.cos(phi) * radius * noise;
            var y = Math.cos(theta) * radius * noise;
            var z = Math.sin(theta) * Math.sin(phi) * radius * noise;
            
            var point = Model.addPoint(x, y, z);
            row.push(point);
        }
        vertices.push(row);
    }
    
    // Create triangles for the sphere
    for (var i = 0; i < subdivisions; i++) {
        for (var j = 0; j < subdivisions; j++) {
            var p1 = vertices[i][j];
            var p2 = vertices[i][j + 1];
            var p3 = vertices[i + 1][j];
            var p4 = vertices[i + 1][j + 1];
            
            Model.addTriangle(p1, p2, p4);
            Model.addTriangle(p1, p4, p3);
        }
    }
    
    // Add crystal spikes on surface
    addCrystalSpikes(radius, subdivisions, vertices);
}

function addCrystalSpikes(radius, subdivisions, baseVertices) {
    var spikeCount = subdivisions * 2;
    
    for (var s = 0; s < spikeCount; s++) {
        var i = Math.floor(Math.random() * (subdivisions - 2)) + 1;
        var j = Math.floor(Math.random() * subdivisions);
        
        var basePoint = baseVertices[i][j];
        
        // Create spike direction
        var spikeLength = radius * (0.1 + Math.random() * 0.3);
        var spike = Model.addPoint(
            basePoint.x * 1.2,
            basePoint.y * 1.2,
            basePoint.z * 1.2
        );
        
        // Connect spike to surrounding vertices
        var nextJ = (j + 1) % subdivisions;
        var prevJ = (j - 1 + subdivisions) % subdivisions;
        
        Model.addTriangle(spike, baseVertices[i][nextJ], baseVertices[i][j]);
        Model.addTriangle(spike, baseVertices[i][prevJ], baseVertices[i][j]);
    }
}